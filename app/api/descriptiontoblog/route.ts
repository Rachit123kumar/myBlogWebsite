import { type NextRequest, NextResponse } from "next/server"
import axios from "axios"
import Numbering from "@/models/numbering"
import Blog from "@/models/blog"
import { connectToDatabase } from "@/lib/db"
import News from "@/models/news"

const API_KEY = process.env.GEMINI_API_KEY!
const MODEL_NAME = "gemini-1.5-flash"

async function searchTavilyNews(query: string) {
  const response = await fetch("https://api.tavily.com/search", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${process.env.TAVILY_API_KEY!}`,
    },
    body: JSON.stringify({
      query: query,
      topic: "news",
      search_depth: "advanced",
      time_range: "day",
    }),
  })

  if (!response.ok) {
    throw new Error(`Tavily API request failed: ${response.statusText}`)
  }

  return await response.json()
}

type NumberingType = {
  number: number
  findingId: number
  totalLength: number
  updatedAt: Date
}

export async function GET(req:NextRequest) {

   const url = new URL(req.url);
     const authQuery = url.searchParams.get("Authorization");
       const expected = `Bearer${process.env.CRON_SECRET}`;
 if (authQuery !== expected) {
    return new NextResponse("Unauthorized", { status: 401 });
  }

  console.log("CRON JOB TRIGGERED");

  await connectToDatabase()

  // Get numbering info
  const datanumbering: NumberingType | null = await Numbering.findOne({ findingId: 1 })


  if (!datanumbering) {
    return NextResponse.json({ error: "No numbering found" }, { status: 400 })
  }

  if (datanumbering.number === datanumbering.totalLength) {
    return NextResponse.json({
      message: "All blog titles have already been used. Please insert new news articles.",
    })
  }

  // Get blog title by number
  console.log(datanumbering, "dataNumbering")
  const mygetBlog = await News.findOne({
    number: Number(datanumbering.number + 1),
  })
  console.log(mygetBlog)
  if (!mygetBlog?.title) {
    return NextResponse.json({ error: "Blog title not found for next number" }, { status: 404 })
  }

  // Fetch news data from Tavily
  const res = await searchTavilyNews(mygetBlog.title)

  // Update the numbering
  await Numbering.findOneAndUpdate(
    { findingId: 1 },
    { number: datanumbering.number + 1, updatedAt: new Date() },
    { new: true }
  )

  // Generate prompt for Gemini
  const prompt = `You are a professional blog writer AI. Use the following structured news data to generate a complete, engaging, and easy-to-read blog post in markdown format (800–1500 words).

### Output Format
- Title: <Title of the Blog>
- Tags: <Comma-separated Tags>
- Content:
<Blog Content in Markdown>

Instructions:
- Use the "query" as the blog title.
- Expand on the "answer" as the article’s main body.
- Use the "results" array to cite real-time insights, quotes, and supporting data from trusted sources.
- Mention article titles and include the source URLs where appropriate.
- Maintain a clear, informative, and accessible tone.
- Format the blog with proper headings, bullet points, and markdown structure.

Here is the data:
${JSON.stringify(res, null, 2)}`;


  // Generate content using Gemini
  try {
    const response = await axios.post(
      `https://generativelanguage.googleapis.com/v1/models/${MODEL_NAME}:generateContent?key=${API_KEY}`,
      {
        contents: [
          {
            parts: [
              {
                text: prompt,
              },
            ],
          },
        ],
      },
      {
        headers: {
          "Content-Type": "application/json",
        },
      }
    )

    const content = response.data.candidates?.[0]?.content?.parts?.[0]?.text
    console.log(content);
    const titleMatch = content.match(/Title:\s*(.*)/);
    const tagsMatch = content.match(/Tags:\s*(.*)/);

    // Extract title and tags
    const title = titleMatch ? titleMatch[1].trim() : "Untitled";
    const tags = tagsMatch ? tagsMatch[1].split(',').map((tag:string) => tag.trim()) : [];

    // mow i have to save this content as content

    const res = await axios.post(`${process.env.NEXT_PUBLIC_APP_URL}/api/save-blog`, {
      title,
      content,
      tags,
      visbility: "public"

    })


    if (!content) {
      throw new Error("No content generated by Gemini")
    }

    return NextResponse.json({
      success: true,
      blog: content,
    })
  } catch (error: any) {
    console.error("Gemini API Error:", error.response?.data || error.message)
    return NextResponse.json({ error: "Failed to generate blog content" }, { status: 500 })
  }
}
